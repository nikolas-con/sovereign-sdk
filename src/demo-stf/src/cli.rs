use std::fs::File;
use std::io::Read;
use std::path::{Path, PathBuf};
use std::{fs, vec};

use anyhow::Context;
use borsh::BorshSerialize;
use clap::Parser;
use demo_stf::app::RollupDaConfig;
use demo_stf::runtime::{borsh_encode_cli_tx, parse_call_message_json, CliTransactionParser};
use jsonrpsee::core::client::ClientT;
use jsonrpsee::http_client::HttpClientBuilder;
use sov_modules_api::default_context::DefaultContext;
use sov_modules_api::default_signature::private_key::DefaultPrivateKey;
use sov_modules_api::transaction::Transaction;
use sov_modules_api::{AddressBech32, PrivateKey, PublicKey, Spec};
use sov_modules_stf_template::RawTx;
use sov_sequencer::SubmitTransaction;
use sov_stf_runner::from_toml_path;
type C = DefaultContext;
type Address = <C as Spec>::Address;

/// Main entry point for CLI
#[derive(Parser)]
#[clap(version = "1.0", author = "Sovereign")]
struct Cli {
    #[clap(subcommand)]
    /// Commands to perform operations
    command: Commands,
}

/// Main commands
#[derive(Parser)]
enum Commands {
    /// Serialize a call to a module.
    /// This creates a .dat file containing the serialized transaction
    GenerateTransactionFromJson {
        /// Path to the json file containing the private key of the sender
        sender_priv_key_path: String,
        /// Name of the module to generate the call.
        /// Modules defined in your Runtime are supported.
        /// (eg: Bank, Accounts)
        module_name: String,
        /// Path to the json file containing the parameters for a module call
        call_data: String,
        /// Nonce for the transaction
        nonce: u64,
    },
    /// Submits transaction to sequencer
    SubmitTransaction {
        /// Path to the json file containing the private key of the sender
        sender_priv_key_path: String,
        /// Name of the module to generate the call.
        /// Modules defined in your Runtime are supported.
        /// (eg: Bank, Accounts)
        module_name: String,
        /// Path to the json file containing the parameters for a module call
        call_data: String,
        /// Nonce for the transaction
        nonce: u64,
        /// RPC endpoint with sequencer RPC
        rpc_endpoint: String,
    },
    /// Tells Sequencer to publish batch
    PublishBatch {
        /// RPC endpoint with sequencer RPC
        rpc_endpoint: String,
    },
    /// Combine a list of files generated by GenerateTransaction into a blob for submission to Celestia
    MakeBatch {
        /// List of files containing serialized transactions
        path_list: Vec<String>,
    },
    /// Utility commands
    Util(UtilArgs),
    /// Generate a transaction from the command line
    #[clap(subcommand)]
    GenerateTransaction(CliTransactionParser<DefaultContext>),
}

#[derive(Parser)]
struct UtilArgs {
    #[clap(subcommand)]
    /// Commands under utilities
    command: UtilCommands,
}

/// List of utility commands
#[derive(Parser)]
enum UtilCommands {
    /// Compute the address of a derived token. This follows a deterministic algorithm
    DeriveTokenAddress {
        /// Name of the token
        token_name: String,
        /// Address of the sender (can be obtained using the show-public-key subcommand)
        sender_address: String,
        /// A random number chosen by the token deployer
        salt: u64,
    },
    /// Display the public key associated with a private key
    ShowPublicKey {
        /// Path to the json file containing the private key
        private_key_path: String,
    },
    /// Create a new private key
    CreatePrivateKey {
        /// Folder to store the new private key json file. The filename is auto-generated
        priv_key_path: String,
    },
    PrintNamespace,
}

struct SerializedTx {
    raw: RawTx,
    #[allow(dead_code)]
    sender: Address,
}

#[derive(serde::Serialize, serde::Deserialize, Debug)]
struct PrivKeyAndAddress {
    hex_priv_key: String,
    address: Address,
}

impl PrivKeyAndAddress {
    fn generate() -> Self {
        let priv_key = DefaultPrivateKey::generate();
        let address = priv_key.pub_key().to_address();
        Self {
            hex_priv_key: priv_key.as_hex(),
            address,
        }
    }

    fn generate_and_save_to_file(priv_key_path: &Path) -> anyhow::Result<()> {
        let priv_key = Self::generate();
        let data = serde_json::to_string(&priv_key)?;
        fs::create_dir_all(priv_key_path)?;
        let path = Path::new(priv_key_path).join(format!("{}.json", priv_key.address));
        fs::write(&path, data)?;
        println!(
            "private key written to path: {}",
            path.into_os_string().into_string().unwrap()
        );
        Ok(())
    }
}

impl SerializedTx {
    fn new<P: AsRef<Path>>(
        sender_priv_key_path: P,
        module_name: &str,
        call_data: &str,
        nonce: u64,
    ) -> anyhow::Result<SerializedTx> {
        let sender_priv_key = Self::deserialize_priv_key(sender_priv_key_path)?;
        let sender_address = sender_priv_key.pub_key().to_address();
        let message = parse_call_message_json::<DefaultContext>(module_name, &call_data)?;

        let tx = Transaction::<C>::new_signed_tx(&sender_priv_key, message, nonce);

        Ok(SerializedTx {
            raw: RawTx {
                data: tx.try_to_vec()?,
            },
            sender: sender_address,
        })
    }

    fn deserialize_priv_key<P: AsRef<Path>>(
        sender_priv_key_path: P,
    ) -> anyhow::Result<DefaultPrivateKey> {
        let priv_key_data = std::fs::read_to_string(&sender_priv_key_path).with_context(|| {
            format!(
                "Failed to read private key from {:?}",
                sender_priv_key_path.as_ref()
            )
        })?;

        let sender_priv_key_data = serde_json::from_str::<PrivKeyAndAddress>(&priv_key_data)?;

        Ok(DefaultPrivateKey::from_hex(
            &sender_priv_key_data.hex_priv_key,
        )?)
    }

}

fn serialize_call(command: &Commands) -> Result<String, anyhow::Error> {
    if let Commands::GenerateTransactionFromJson {
        sender_priv_key_path,
        module_name,
        call_data,
        nonce,
    } = command
    {
        let serialized =
            SerializedTx::new(&sender_priv_key_path, module_name, &call_data, *nonce)
                .context("Call message serialization error")?;

        Ok(hex::encode(serialized.raw.data))
    } else {
        Ok(Default::default())
    }
}

fn make_hex_blob(txs: impl Iterator<Item = String>) -> Result<String, anyhow::Error> {
    // decode the hex string to bytes
    let mut batch = vec![];
    for tx in txs {
        let bytes = hex::decode(tx.as_bytes())
            .with_context(|| format!("Unable to decode {} as hex", tx))?;
        batch.push(bytes);
    }
    Ok(hex::encode(
        batch
            .try_to_vec()
            .expect("Serializing to a vector is infallible."),
    ))
}

#[tokio::main]
pub async fn main() -> Result<(), anyhow::Error> {
    let cli = Cli::parse();

    match cli.command {
        Commands::GenerateTransactionFromJson {
            ref call_data, ..
        } => {
            let raw_contents = serialize_call(&cli.command)?;
            let mut bin_path = PathBuf::from(call_data);
            bin_path.set_extension("dat");

            println!("{}", raw_contents)
        }
        Commands::SubmitTransaction {
            sender_priv_key_path,
            module_name,
            call_data,
            nonce,
            rpc_endpoint,
        } => {
            let serialized =
                SerializedTx::new(&sender_priv_key_path, &module_name, &call_data, nonce)
                    .context("Unable to serialize call transaction")?;

            let request = SubmitTransaction::new(serialized.raw.data);
            let client = HttpClientBuilder::default().build(rpc_endpoint).unwrap();
            let response: String = client
                .request("sequencer_acceptTx", [request])
                .await
                .context("Unable to submit transaction")?;

            println!(
                "Your transaction was submitted to the sequencer. Response: {}",
                response
            );
        }
        Commands::PublishBatch { rpc_endpoint } => {
            let client = HttpClientBuilder::default().build(rpc_endpoint).unwrap();

            let response: String = client
                .request("sequencer_publishBatch", [1u32])
                .await
                .context("Unable to publish batch")?;

            // Print the result
            println!(
                "Your batch was submitted to the sequencer for publication. Response: {:?}",
                response
            );
        }
        Commands::MakeBatch { path_list } => {
            let mut hex_encoded_txs = vec![];
            for path in path_list {
                let mut file =
                    File::open(&path).with_context(|| format!("Unable to create file {}", path))?;
                let mut hex_string = String::new();
                file.read_to_string(&mut hex_string)
                    .context("Unable to read the file")?;
                let hex_string_trim = hex_string.trim().to_string();
                hex_encoded_txs.push(hex_string_trim);
            }

            let blob = make_hex_blob(hex_encoded_txs.into_iter())?;
            println!("{}", blob)
        }
        Commands::Util(util_args) => match util_args.command {
            UtilCommands::DeriveTokenAddress {
                token_name,
                sender_address,
                salt,
            } => {
                let sender_address = Address::from(
                    AddressBech32::try_from(sender_address.clone()).with_context(|| {
                        format!(
                            "Could not parse {} as a valid bech32 address",
                            sender_address,
                        )
                    })?,
                );
                let token_address =
                    sov_bank::get_token_address::<C>(&token_name, sender_address.as_ref(), salt);
                println!("{}", token_address);
            }

            UtilCommands::ShowPublicKey { private_key_path } => {
                let sender_priv_key = SerializedTx::deserialize_priv_key(private_key_path)
                    .context("Failed to get private key from file")?;
                let sender_address: Address = sender_priv_key.pub_key().to_address();
                println!("{}", sender_address);
            }

            UtilCommands::CreatePrivateKey { priv_key_path } => {
                PrivKeyAndAddress::generate_and_save_to_file(priv_key_path.as_ref())
                    .context("Could not create private key")?;
            }
            UtilCommands::PrintNamespace => {

                let rollup_da_config: RollupDaConfig =
                    from_toml_path("rollup_config.toml").context("Failed to read rollup configuration")?;
                
                println!("{}", hex::encode(rollup_da_config.da_rollup_namespace));
            }
        },
        Commands::GenerateTransaction(cli_tx) => {
            println!("{}", hex::encode(borsh_encode_cli_tx(cli_tx)));
        }
    }

    Ok(())
}

#[cfg(test)]
#[path = "tests/sov_sli.rs"]
mod tests;
